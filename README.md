Я создал систему независимо действующих нейронов, которые ищут соединения друг с другом исходя из своей полезности. И немного ее подстроил для прогнозирования движения цен. В частности, направления движения цен акции Nvidia.

Небольшое описание.
Синапс получает информацию из контакта с аксоном.
Далее дендрит соединяет сигналы из своих синапсов, активных в текущий период. У каждого дендрита есть много синапсов. 
После этого нейрон суммирует сигналы из своих дендритов и проводит через фильтр. Информация передается в аксоны. И новый период начинается. 

Основные вычисления происходят в синапсах. В данной версии модели я добавил еще и дифференциальный подход. Возбуждение энергии в синапсе зависит от прошлых вычислений. Я сделал это через простой дискретный коэффициент. Если прошлый результат был выше заданного порога, то коэффициент повышается. 

Кроме того, исходящий из аксона сигнал претерпевает изменения во внешней среде. До попадания в синапс. В моем случае это просто внешний коэффициент.

Я использовал систему узлов, как координатной сетки, чтобы рассчитывать притяжения и движения дендритов. 

Каждый дендрит движется к самому привлекательному узлу. Привлекательность обратно-пропорциональна квадрату расстояния и пропорциональная энергии узла. Я использовал количество образованных контактов синапсов. 

Каждый период каждый дендрит определяет привлекательный узел и начинает расти в его сторону. Если по ходу роста дендрит проходит через новую для себя территорию, то он отращивает синапсы.

Уже внутри узла синапсы случайным образом стыкуются с аксонами. Связь установлена, если в общей системе не происходит падения полезности. Именно здесь и происходит обучение системы как цельной сущности. 

Также я предусмотрел механизм разрыва связи. При определенных обстоятельствах синапс разрывает связь, и если полезность в данном периоде не упала, то разрыв остается валиден. 

Архитектура сети.
У нас есть восемь особых воспринимающих нейронов, которые видят только положительные доходности. И восемь только для отрицательных. И, соответственно, система смотрит только на восемь периодов назад. 


Далее существует несколько заранее определенных замороженных контактов, которые не могут быть изменены. На самом деле они не особо нужны, но я подумал они дают некоторую стабилизацию. Есть также два выходных нейрона. Один для движения вниз, другой вверх. А всего порядка шестидесяти нейронов. У каждого по 15 дендритов, а у каждого дендрита по пять умножить на число узлов, в которых находится дендрит. 

Информация течет последовательно, то есть каждый период синапс получает сигнал от аксона, происходит преобразование и то, что получилось уходит уже в аксоны данного нейрона. Но из них сигнал уходит уже в следующий период. 

Получается вот такая меняющаяся и движущаяся система.
Кроме того, сигналы из системы "выветривается" без дополнительных импульсов, что правильно для сложных систем. Поэтому при обучении мы находим оптимальный временной маркер. И уже на нем проверяем итоговую функцию полезности.

Функция полезности очень простая. Если система верно определяет движение следующего периода, то получает плюс один к полезности. Если ошибается, то минус три. Неудачи весят больше, чем победы. Как у людей.
А теперь самое интересное. Результаты.

Я не обучал на всех доступных данных у акций Nvidia. Обучение было всего на двадцати периодах, и я проверял результат на следующих двадцати периодах. И так я сделал порядка двадцати раз. 

Напомню, мы предсказываем только направление движения. Основной вывод таков: если на тренировочном периоде точность выше 0.5 и ниже 0.66, то смело можно использовать результаты подсказки интеллекта. При точности выше 0.66 наблюдается переобучение.
На самом деле, если точность ниже 0.5 можно пользоваться предсказаниями сети, но с обратным знаком. Результат не такой стабильный, но почти всегда верный. 

Интересно получается, и это без нужды в градиентах. Пока проблема в сохранении данных. То есть, сохранить все соединения синапсов и внутренние характеристики нейронов не представляет проблем. Но вот как подгружать простым способом я не знаю.



